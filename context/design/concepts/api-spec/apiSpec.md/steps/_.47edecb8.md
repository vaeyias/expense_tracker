---
timestamp: 'Tue Oct 21 2025 00:59:31 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251021_005931.09524ce7.md]]'
content_id: 47edecb806c110621263f1436f17e414fdf33f0f71d87c2c6ababdb27577b990
---

# implementation

```typescript
import { Collection, Db } from "npm:mongodb";
import { ID } from "@utils/types.ts"; // Assuming ID is a type alias for string with branding
import { freshID } from "@utils/database.ts";

// Define User type (assuming it is globally defined or imported)
// For demonstration, we'll define them as ID
type User = ID;

// Declare collection prefix
const PREFIX = "Debt" + ".";

/**
 * Represents a personal debt between two users.
 * userA owes userB if balance is positive.
 */
interface Debt {
  _id: ID; // Unique identifier for the personal debt record
  userA: User;
  userB: User;
  balance: number; // positive if userA owes userB, negative if userB owes userA
}

export default class DebtConcept {
  debts: Collection<Debt>;

  constructor(private readonly db: Db) {
    this.debts = this.db.collection(PREFIX + "debts");
  }

  /**
   * Creates a new personal debt record between two users.
   * @param userA The first user.
   * @param userB The second user.
   * @returns The newly created personal debt record.
   */
  async createDebt({
    userA,
    userB,
  }: {
    userA: User;
    userB: User;
  }): Promise<{ debt: Debt } | { error: string }> {
    // Requires: both users exist and a Debt between them does not already exist
    // This check would typically involve querying user collection (not provided here)
    // and checking for existing debts between userA and userB.
    // For simplicity, we'll assume the existence and uniqueness checks are handled externally or by caller.

    const existingDebt = await this.debts.findOne({
      $or: [
        { userA: userA, userB: userB },
        { userA: userB, userB: userA },
      ],
    });

    if (existingDebt) {
      return { error: "Debt already exists between these users." };
    }

    const newDebt: Debt = {
      _id: await freshID(), // Assuming freshID() is available for generating unique IDs
      userA: userA,
      userB: userB,
      balance: 0,
    };
    await this.debts.insertOne(newDebt);
    return { debt: newDebt };
  }

  /**
   * Updates the balance of an existing personal debt between two users.
   * @param payer The user who is paying.
   * @param receiver The user who is receiving the payment.
   * @param amount The amount of the payment.
   * @returns The updated balance between the payer and receiver.
   */
  async updateDebt({
    payer,
    receiver,
    amount,
  }: {
    payer: User;
    receiver: User;
    amount: number;
  }): Promise<{ balance: number } | { error: string }> {
    // Requires: a Debt exists between payer and receiver
    const debt = await this.debts.findOne({
      $or: [
        { userA: payer, userB: receiver },
        { userA: receiver, userB: payer },
      ],
    });

    if (!debt) {
      return {
        error: "Debt does not exist between payer and receiver.",
      };
    }

    let updatedBalance: number;

    if (debt.userA === payer) {
      // payer is userA, receiver is userB
      // If payer pays receiver, payer's balance should decrease (they owe less to receiver)
      // If payer is userA, and userA pays userB, the balance (userA owes userB) should decrease.
      // So, debt.balance = debt.balance - amount
      updatedBalance = debt.balance - amount;
    } else {
      // payer is userB, receiver is userA
      // If payer pays receiver, payer's balance should increase (they owe more to receiver)
      // If payer is userB, and userB pays userA, the balance (userA owes userB) should increase.
      // So, debt.balance = debt.balance + amount
      updatedBalance = debt.balance + amount;
    }

    await this.debts.updateOne(
      { _id: debt._id },
      { $set: { balance: updatedBalance } },
    );

    return { balance: updatedBalance };
  }

  /**
   * Deletes an existing debt between two users.
   * @param userA The first user.
   * @param userB The second user.
   * @returns Success object or error if debt does not exist.
   */
  async deleteDebt({
    userA,
    userB,
  }: {
    userA: User;
    userB: User;
  }): Promise<{} | { error: string }> {
    const debt = await this.debts.findOne({
      $or: [
        { userA: userA, userB: userB },
        { userA: userB, userB: userA },
      ],
    });

    if (!debt) {
      return { error: "Debt does not exist between these users." };
    }

    await this.debts.deleteOne({ _id: debt._id });
    return {}; // success
  }

  /**
   * Gets the net balance between two users.
   * @param userA The first user.
   * @param userB The second user.
   * @returns The net balance between userA and userB.
   */
  async getDebt({
    userA,
    userB,
  }: {
    userA: User;
    userB: User;
  }): Promise<{ balance: number } | { error: string }> {
    // Requires: a Debt exists between the two users
    const debt = await this.debts.findOne({
      $or: [
        { userA: userA, userB: userB },
        { userA: userB, userB: userA },
      ],
    });

    if (!debt) {
      return { error: "Debt does not exist between these users." };
    }

    // The balance is stored as 'userA owes userB'.
    // If the query is for userB owes userA, we need to invert the sign.
    if (debt.userA === userA && debt.userB === userB) {
      return { balance: debt.balance };
    } else if (debt.userA === userB && debt.userB === userA) {
      return { balance: -debt.balance }; // Invert balance if userA is the receiver in the stored record
    } else {
      // This case should ideally not be reached due to the $or query, but as a safeguard:
      return { error: "Unexpected debt record structure." };
    }
  }

  /**
   * Lists all debts involving a given user with non-zero balance.
   */
  async _listDebtsForUser({ user }: { user: User }): Promise<Debt[]> {
    const debtsRes = await this.debts
      .find({
        balance: { $ne: 0 },
        $or: [
          { userA: user },
          { userB: user },
        ],
      }).toArray();

    console.log(debtsRes);

    return debtsRes;
  }

  /**
   * Computes the net balance of a user across all debts.
   * Positive = others owe this user, Negative = this user owes others.
   */
  async _getNetBalance(user: User): Promise<number> {
    const debts = await this._listDebtsForUser({ user });
    let total = 0;

    for (const d of debts) {
      if (d.userA === user) {
        // user owes userB
        total -= d.balance;
      } else if (d.userB === user) {
        // userB is owed by userA
        total += d.balance;
      }
    }

    return total;
  }
}

```
