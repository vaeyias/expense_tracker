---
timestamp: 'Sun Oct 12 2025 01:36:54 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251012_013654.6d1536d4.md]]'
content_id: bb91604b5869b0df96e226a922e591c1afc4ad1bf850f0d219e52be5cf55508d
---

# modified\_implementation

```
import { Collection, Db } from "npm:mongodb";
import { ID } from "@utils/types.ts"; // Assuming ID is a type alias for string with branding
import { freshID } from "@utils/database.ts";

// Define User and Expense types (assuming they are globally defined or imported)
// For demonstration, we'll define them as ID
type User = ID;
type Expense = ID; // Reference to an expense object

// Declare collection prefix
const PREFIX = "Debt" + ".";

/**
 * Represents a personal debt between two users.
 * userA owes userB if balance is positive.
 */
interface PersonalDebt {
  _id: ID; // Unique identifier for the personal debt record
  userA: User;
  userB: User;
  balance: number; // positive if userA owes userB, negative if userB owes userA
}

/**
 * Represents a record of a specific debt transaction, usually tied to an expense.
 */
interface DebtRecord {
  _id: ID; // Unique identifier for the debt record
  payer: User;
  receiversSplits: Record<User, number>; // Map of user to the amount they owe the payer for this record
  expense: Expense; // Reference to the associated expense
}

export default class DebtConcept {
  personalDebts: Collection<PersonalDebt>;
  debtRecords: Collection<DebtRecord>;

  constructor(private readonly db: Db) {
    this.personalDebts = this.db.collection(PREFIX + "personalDebts");
    this.debtRecords = this.db.collection(PREFIX + "debtRecords");
  }

  /**
   * Creates a new personal debt record between two users.
   * @param userA The first user.
   * @param userB The second user.
   * @returns The newly created personal debt record.
   */
  async createPersonalDebt({
    userA,
    userB,
  }: {
    userA: User;
    userB: User;
  }): Promise<{ debt: PersonalDebt } | { error: string }> {
    // Requires: both users exist and a PersonalDebt between them does not already exist
    // This check would typically involve querying user collection (not provided here)
    // and checking for existing personalDebts between userA and userB.
    // For simplicity, we'll assume the existence and uniqueness checks are handled externally or by caller.

    const existingDebt = await this.personalDebts.findOne({
      $or: [
        { userA: userA, userB: userB },
        { userA: userB, userB: userA },
      ],
    });

    if (existingDebt) {
      console.log("HI");
      return { error: "Personal debt already exists between these users." };
    }

    const newDebt: PersonalDebt = {
      _id: await freshID(), // Assuming freshID() is available for generating unique IDs
      userA: userA,
      userB: userB,
      balance: 0,
    };
    await this.personalDebts.insertOne(newDebt);
    return { debt: newDebt };
  }

  /**
   * Updates the balance of an existing personal debt between two users.
   * @param payer The user who is paying.
   * @param receiver The user who is receiving the payment.
   * @param amount The amount of the payment.
   * @returns The updated balance between the payer and receiver.
   */
  async updatePersonalDebt({
    payer,
    receiver,
    amount,
  }: {
    payer: User;
    receiver: User;
    amount: number;
  }): Promise<{ balance: number } | { error: string }> {
    // Requires: a PersonalDebt exists between payer and receiver
    const debt = await this.personalDebts.findOne({
      $or: [
        { userA: payer, userB: receiver },
        { userA: receiver, userB: payer },
      ],
    });

    if (!debt) {
      return {
        error: "Personal debt does not exist between payer and receiver.",
      };
    }

    let updatedBalance: number;

    if (debt.userA === payer) {
      // payer is userA, receiver is userB
      // If payer pays receiver, payer's balance should decrease (they owe less to receiver)
      // If payer is userA, and userA pays userB, the balance (userA owes userB) should decrease.
      // So, debt.balance = debt.balance - amount
      updatedBalance = debt.balance - amount;
    } else {
      // payer is userB, receiver is userA
      // If payer pays receiver, payer's balance should increase (they owe more to receiver)
      // If payer is userB, and userB pays userA, the balance (userA owes userB) should increase.
      // So, debt.balance = debt.balance + amount
      updatedBalance = debt.balance + amount;
    }

    await this.personalDebts.updateOne(
      { _id: debt._id },
      { $set: { balance: updatedBalance } },
    );

    return { balance: updatedBalance };
  }

  /**
   * Creates a new debt record for a shared expense.
   * @param payer The user who paid for the expense.
   * @param totalCost The total cost of the expense.
   * @param receiversSplit A map of users to the amount they owe the payer for this expense.
   * @returns The newly created debt record.
   */
  async createDebtRecord({
    payer,
    totalCost,
    receiversSplit,
    expenseId,
  }: {
    payer: User;
    totalCost: number;
    receiversSplit: Record<User, number>;
    expenseId: ID;
  }): Promise<{ debtRecord: DebtRecord } | { error: string }> {
    // Validation: all debtMapping amounts are non-negative
    for (const [user, amount] of Object.entries(receiversSplit)) {
      if (amount < 0) {
        return { error: `Debt for user ${user} cannot be negative` };
      }
    }

    // Validation: sum of splits equals totalCost
    const totalDebt = Object.values(receiversSplit).reduce((a, b) => a + b, 0);
    if (Math.abs(totalDebt - totalCost) > 0.001) { // Use tolerance for float comparison
      return { error: "Sum of receiver splits must equal total cost." };
    }

    if (totalCost < 0) {
      return { error: "Total cost cannot be negative." };
    }

    const newDebtRecord: DebtRecord = {
      _id: await freshID(),
      payer: payer,
      receiversSplits: receiversSplit,
      expense: expenseId,
    };

    // Update personal debt balances
    for (const [receiver, amountOwed] of Object.entries(receiversSplit)) {
      if (payer !== receiver) { // Don't update debt if payer is also receiver for this split amount
        await this.updatePersonalDebt({
          payer: receiver as User, // The receiver owes the payer
          receiver: payer,
          amount: amountOwed,
        });
      }
    }

    await this.debtRecords.insertOne(newDebtRecord);
    return { debtRecord: newDebtRecord };
  }

  /**
   * Edits an existing debt record and recalculates affected personal debt balances.
   * @param debtRecordId The ID of the debt record to edit.
   * @param totalCost The new total cost of the expense.
   * @param receiversSplit The new map of users and amounts owed.
   * @returns The updated debt record.
   */
  async editDebtRecord({
    debtRecordId,
    totalCost,
    receiversSplit,
  }: {
    debtRecordId: ID;
    totalCost: number;
    receiversSplit: Record<User, number>;
  }): Promise<{ debtRecord: DebtRecord } | { error: String }> {
    // Requires: debtRecord exists, totalCost > 0, all receivers exist, numbers in receiversSplit are nonnegative and sum to totalCost

    const existingDebtRecord = await this.debtRecords.findOne({
      _id: debtRecordId,
    });

    if (!existingDebtRecord) {
      return { error: "Debt record not found." };
    }

    for (const [user, amount] of Object.entries(receiversSplit)) {
      if (amount < 0) {
        return { error: `Debt for user ${user} cannot be negative` };
      }
    }

    // Validation: sum of splits equals totalCost
    const totalDebt = Object.values(receiversSplit).reduce((a, b) => a + b, 0);
    if (Math.abs(totalDebt - totalCost) > 0.001) { // Use tolerance for float comparison
      return { error: "Sum of receiver splits must equal total cost." };
    }

    if (totalCost <= 0) {
      return { error: "Total cost must be positive." };
    }

    // To accurately recalculate balances, we first need to reverse the effects of the old record.
    // For each receiver in the old record, subtract their owed amount from the payer.
    for (
      const [receiver, amountOwed] of Object.entries(
        existingDebtRecord.receiversSplits,
      )
    ) {
      if (existingDebtRecord.payer !== receiver) {
        await this.updatePersonalDebt({
          payer: receiver as User,
          receiver: existingDebtRecord.payer,
          amount: -amountOwed, // Add the new amount
        });
      }
    }

    // Then, apply the effects of the new receivers split.
    for (const [receiver, amountOwed] of Object.entries(receiversSplit)) {
      if (existingDebtRecord.payer !== receiver) {
        await this.updatePersonalDebt({
          payer: receiver as User,
          receiver: existingDebtRecord.payer,
          amount: amountOwed, // Add the new amount
        });
      }
    }

    const updatedDebtRecord: DebtRecord = {
      ...existingDebtRecord,
      receiversSplits: receiversSplit,
    };

    await this.debtRecords.updateOne(
      { _id: debtRecordId },
      { $set: updatedDebtRecord },
    );

    return { debtRecord: updatedDebtRecord };
  }

  /**
   * Deletes a debt record and adjusts affected personal debt balances.
   * @param debtRecordId The ID of the debt record to delete.
   * @returns An empty object on success, or an error object.
   */
  async deleteDebtRecord({
    debtRecordId,
  }: {
    debtRecordId: ID;
  }): Promise<any> { // Returning 'any' to allow for error object or empty success
    // Requires: debtRecord exists
    const existingDebtRecord = await this.debtRecords.findOne({
      _id: debtRecordId,
    });

    if (!existingDebtRecord) {
      return { error: "Debt record not found." };
    }

    // Reverse the effects of the debt record
    for (
      const [receiver, amountOwed] of Object.entries(
        existingDebtRecord.receiversSplits,
      )
    ) {
      if (existingDebtRecord.payer !== receiver) {
        await this.updatePersonalDebt({
          payer: receiver as User,
          receiver: existingDebtRecord.payer,
          amount: -amountOwed, // Subtract the owed amount
        });
      }
    }

    await this.debtRecords.deleteOne({ _id: debtRecordId });

    return {}; // Success, return empty object
  }

  /**
   * Gets the net balance between two users.
   * @param userA The first user.
   * @param userB The second user.
   * @returns The net balance between userA and userB.
   */
  async getDebt({
    userA,
    userB,
  }: {
    userA: User;
    userB: User;
  }): Promise<{ balance: number } | { error: string }> {
    // Requires: a PersonalDebt exists between the two users
    const debt = await this.personalDebts.findOne({
      $or: [
        { userA: userA, userB: userB },
        { userA: userB, userB: userA },
      ],
    });

    if (!debt) {
      return { error: "Personal debt does not exist between these users." };
    }

    // The balance is stored as 'userA owes userB'.
    // If the query is for userB owes userA, we need to invert the sign.
    if (debt.userA === userA && debt.userB === userB) {
      return { balance: debt.balance };
    } else if (debt.userA === userB && debt.userB === userA) {
      return { balance: -debt.balance }; // Invert balance if userA is the receiver in the stored record
    } else {
      // This case should ideally not be reached due to the $or query, but as a safeguard:
      return { error: "Unexpected debt record structure." };
    }
  }
}

```
