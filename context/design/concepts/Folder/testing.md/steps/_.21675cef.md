---
timestamp: 'Wed Oct 15 2025 17:32:12 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251015_173212.e29bf297.md]]'
content_id: 21675cef54004a6fca8b48bed5398712b3f23d9d067b85fa8607194e17649656
---

# EXAMPLE

## USE THIS AS A TEMPLATE FOR HOW TO FORMAT LOGS

````javascript
import { assertEquals, assertNotEquals } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import { ID } from "@utils/types.ts";
import DebtConcept from "./DebtConcept.ts";

Deno.test("ðŸ’µ DebtConcept - full workflow and edge cases", async (t) => {
  const [db, client] = await testDb();
  const debtConcept = new DebtConcept(db);

  const alice = "user:Alice" as ID;
  const bob = "user:Bob" as ID;
  const charlie = "user:Charlie" as ID;

  // Test Case #1: Create, update, and retrieve debts between users
  await t.step("Test Case #1: Full debt workflow", async () => {
    console.log("[1] Creating Debts between Alice, Bob, Charlie...");
    const aliceBobDebtRes = await debtConcept.createDebt({
      userA: alice,
      userB: bob,
    });

    const charlieAliceDebtRes = await debtConcept.createDebt({
      userA: charlie,
      userB: alice,
    });

    const bobCharlieDebtRes = await debtConcept.createDebt({
      userA: bob,
      userB: charlie,
    });

    assertNotEquals("error" in aliceBobDebtRes, true);
    assertNotEquals("error" in charlieAliceDebtRes, true);
    assertNotEquals("error" in bobCharlieDebtRes, true);

    console.log(
      "[1] Updating debts.. Bob gives Alice 30. Charlie gives Alice 60",
    );

    await debtConcept.updateDebt({
      payer: bob,
      receiver: alice,
      amount: 30,
    });

    await debtConcept.updateDebt({
      payer: charlie,
      receiver: alice,
      amount: 60,
    });

    let aliceBobDebt = await debtConcept.getDebt({
      userA: alice,
      userB: bob,
    });
    let aliceCharlieDebt = await debtConcept.getDebt({
      userA: alice,
      userB: charlie,
    });
    console.log(
      `[1] Debts: Alice owes Bob: ${
        (aliceBobDebt as { balance: number }).balance
      }, Alice owes Charlie: ${
        (aliceCharlieDebt as { balance: number }).balance
      }`,
    );

    aliceBobDebt = await debtConcept.getDebt({
      userA: bob,
      userB: alice,
    });
    aliceCharlieDebt = await debtConcept.getDebt({
      userA: charlie,
      userB: alice,
    });

    console.log(
      `[1] Checking directionality... Bob owes Alice: ${
        (aliceBobDebt as { balance: number }).balance
      }, Charlie owes Alice: ${
        (aliceCharlieDebt as { balance: number }).balance
      }`,
    );

    assertEquals((aliceBobDebt as { balance: number }).balance, -30);
    assertEquals((aliceCharlieDebt as { balance: number }).balance, -60);

    console.log("[1] Updating debts.. Alice gives Charlie back 100");
    await debtConcept.updateDebt({
      payer: alice,
      receiver: charlie,
      amount: 100,
    });

    aliceCharlieDebt = await debtConcept.getDebt({
      userA: alice,
      userB: charlie,
    });

    aliceBobDebt = await debtConcept.getDebt({
      userA: alice,
      userB: bob,
    });

    console.log(
      `[1] Debts: Alice owes Bob: ${
        (aliceBobDebt as { balance: number }).balance
      }, Alice owes Charlie: ${
        (aliceCharlieDebt as { balance: number }).balance
      }`,
    );

    assertEquals((aliceBobDebt as { balance: number }).balance, 30);
    assertEquals((aliceCharlieDebt as { balance: number }).balance, -40);
  });

  // Test Case #2: Creating duplicate debt returns error
  await t.step(
    "Test Case #2: Creating Duplicate Debts and Deleting Debts",
    async () => {
      const duplicate = await debtConcept.createDebt({
        userA: bob,
        userB: alice,
      });
      console.log(
        `[2] Attempted duplicate debt creation (userA: bob, userB: alice), got an error as expected: ${
          (duplicate as { error: string }).error
        }`,
      );
      assertEquals("error" in duplicate, true);

      console.log(`[2] Deleting Alice and Bob's debt...`);
      await debtConcept.deleteDebt({ userA: alice, userB: bob });
      console.log(
        `[2] Attempting to create a debt between Alice and Bob again...`,
      );
      const newDebt = await debtConcept.createDebt({
        userA: bob,
        userB: alice,
      });

      assertEquals("error" in newDebt, false);

      const initialBalance = await debtConcept.getDebt({
        userA: bob,
        userB: alice,
      });

      console.log(
        `[2] Successfully created debt: Bob owes Alice: ${
          (initialBalance as { balance: number }).balance
        }`,
      );
    },
  );

  // Test Case #3: Querying, Updating non-existent debt returns error
  await t.step("Test Case #3: Querying non-existent debt", async () => {
    const res = await debtConcept.getDebt({
      userA: alice,
      userB: "user:Unknown" as ID,
    });
    console.log(
      `[3] Querying non-existent debt returns error as expected: ${
        (res as { error: string }).error
      }`,
    );
    assertEquals("error" in res, true);

    await debtConcept.deleteDebt({ userA: charlie, userB: bob });
    console.log(`[3] Deleting debt between Bob and Charlie...`);
    const res2 = await debtConcept.updateDebt({
      payer: charlie,
      receiver: bob,
      amount: 20,
    });
    assertEquals("error" in res2, true);
    console.log(
      `[3] Updating non-existent debt between Bob and Charlie, got error as expected: ${
        (res as { error: string }).error
      }`,
    );
  });

  await client.close();
});```
````

## MAKE THESE SPECIFIC TEST CASES:

* Test #1: Full workflow- create folder, rename folder, add group to folder, remove group from folder, delete folder

* Test #2: Trying to Delete Folders with Groups Inside

* Test #3: Adding the groups already in folder, Adding group to non-existent folder
